{"meta":{"title":"原质，纯粹","subtitle":"记录的是文字，回忆的是人生","description":null,"author":"暮城","url":"https://jsonya.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-04-25T12:15:04.324Z","updated":"2019-04-25T12:15:04.324Z","comments":false,"path":"/404.html","permalink":"https://jsonya.github.io//404.html","excerpt":"","text":""}],"posts":[{"title":"new 实现","slug":"new-实现","date":"2019-04-12T15:29:45.000Z","updated":"2019-04-25T12:15:04.324Z","comments":true,"path":"2019/04/12/new-实现/","link":"","permalink":"https://jsonya.github.io/2019/04/12/new-实现/","excerpt":"","text":"构造函数和实例化js中可以通过构造函数批量创建对象，创建的过程通过new关键词实现，这个过程也叫实例化，实例化的对象具有默认的属性和原型方法1234567891011function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.sayHello = function() &#123; console.log(`My name is $&#123;this.name&#125;, I'm $&#123;this.age&#125; years old`);&#125;const jsonya = new Person('jsonya', 25);jsonya.sayHello(); new 的过程做了什么？ 创建一个空对象 将这个空对象的原型指向构造函数的原型 执行构造函数，并将默认属性挂载到这个空对象上 判断构造函数的返回值，如果是对象则返回这个对象，否则返回这个空对象 模拟new 关键字？123456789101112131415161718192021222324// New 函数的第一个参数为构造函数，剩余的参数为实例化传入的参数function New() &#123; // step1: 创建一个空对象 const obj = &#123;&#125;; // 获取构造函数，默认是第一个参数为构造函数，所以利用数组将参数第一个推出，原来的arguments只剩下非构造函数部分 const Constructor = [].shift.call(arguments); // step2: 将这个空对象的原型指向构造函数原型 obj.__proto__ = Constructor.prototype; // step3: 执行构造函数，并且将属性挂载到空对象 const result = Constructor.apply(obj, arguments); // step4: 判断返回值是不是对象 return result instanceof Object ? result : obj;&#125;function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.sayHello = function() &#123; console.log(`my name is $&#123;this.name&#125;, I'm $&#123;this.age&#125; years old`);&#125;// 执行const jsonya = New(Person, 'jsonya', 25);jsonya.sayHello(); ok，实现了一个new了，但其实我们通过分析原生的new方法可以看出，在new一个函数的时候，会返回一个func同时在这个func里面会返回一个对象Object，这个对象包含父类func的属性以及隐藏的__proto__ 1234567891011121314151617181920212223function New(Constructor) &#123; return function() &#123; // step1: 创建一个空对象 const obj = &#123;&#125;; // step2: 将这个空对象的原型指向构造函数原型 obj.__proto__ = Constructor.prototype; // step3: 执行构造函数，并且将属性挂载到空对象 const result = Constructor.apply(obj, arguments); // step4: 判断返回值是不是对象 return result instanceof Object ? result : obj; &#125;&#125;function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.sayHello = function() &#123; console.log(`my name is $&#123;this.name&#125;, I'm $&#123;this.age&#125; years old`);&#125;const jsonya = New(Person)('jsonya', 25);jsonya.sayHello(); 可以看出我们的第二种实现原理上是一致的 ，只不过我们将构造函数和参数区分开了","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://jsonya.github.io/tags/js/"}]},{"title":"常用正则记录","slug":"常用正则记录","date":"2018-07-13T18:15:11.000Z","updated":"2019-04-25T12:15:04.324Z","comments":true,"path":"2018/07/13/常用正则记录/","link":"","permalink":"https://jsonya.github.io/2018/07/13/常用正则记录/","excerpt":"","text":"正则解析\bResExr 常用正则\b123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// 是否含有英文字符/.*?[a-zA-Z]+.*?/// 是否含中文字符:/.*?[\\u4E00-\\u9FA5]+.*?/// 是否含特殊字符:/[`~!@#$^&amp;()=|&#123;&#125;’:;’,.&lt;&gt;/?~！@#￥……&amp;（）;|&#123;&#125;【】‘；：”“’。，、？《》]/// 验证邮件: /^([\\w]+([\\w-\\.+]*[\\w-]+)?)@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.)|(([\\w-]+\\.)+))([a-zA-Z]&#123;2,4&#125;|[0-9]&#123;1,3&#125;)(\\]?)$/i// 验证url: ^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)[a-z0-9]+([\\-\\.]&#123;1&#125;[a-z0-9]+)*\\.[a-z]&#123;2,5&#125;(:[0-9]&#123;1,5&#125;)?$// 验证手机号码：^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\\d&#123;8&#125;$// 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?// 手机号码：^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\\d&#123;8&#125;$// 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ // 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; // 18位身份证号码(数字、字母x结尾)：^((\\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$// 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$// 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$// 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ // 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;// 数字：^[0-9]*$// n位的数字：^\\d&#123;n&#125;$// 至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$// 零和非零开头的数字：^(0|[1-9][0-9]*)$// 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$// 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$// 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$// 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$// 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$// 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$// 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$// 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$// 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$// 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$// 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$// 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$// 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$// 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$// 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$// 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$// 长度为3-20的所有字符：^.&#123;3,20&#125;$// 由26个英文字母组成的字符串：^[A-Za-z]+$// 由26个大写英文字母组成的字符串：^[A-Z]+$// 由26个小写英文字母组成的字符串：^[a-z]+$// 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$// 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$// 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$// 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$// 可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+// 禁止输入含有~的字符：[^~\\x22]+","categories":[],"tags":[{"name":"Regexp","slug":"Regexp","permalink":"https://jsonya.github.io/tags/Regexp/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://jsonya.github.io/tags/正则表达式/"}]},{"title":"sentry上传sourcemap","slug":"sentry上传sourcemap","date":"2018-07-03T09:46:15.000Z","updated":"2019-04-25T12:15:04.324Z","comments":true,"path":"2018/07/03/sentry上传sourcemap/","link":"","permalink":"https://jsonya.github.io/2018/07/03/sentry上传sourcemap/","excerpt":"","text":"PS: 本文并没完全成文 前言阅读这篇文章的大前提是你已经创建了一个sentry项目，但是希望在sentry的报错中能够提示更多的信息，所以希望通过sourcemap来定位问题。这篇文章基于vue-cli中的webpack模式，其他模式原理一样。 注意：本文只是提供思路，并不可以用于生产环境，因为涉及到打包流程，而每个项目的打包方式并不一致，所以可以根据此思路去实现自己的上报流程。 sentry-cli构建1)、生成api-key这一步主要是用来上传时登录需要，点击头像 =&gt; 点击API keys 如果你已经创建过token，你的界面会和我一样，如果没创建，根据提示创济南即可，但注意一点的是，需要勾选project:write 2）、安装sentry-cli 先全局安装sentry-cli 1npm install sentry-cli-binary -g 安装完成后登录sentry 1sentry-cli login 这时会提示输入token，把刚才第一步创建的token粘贴到这里，运行 然后你会看到提示创建了一个.sentrylrc文件，文件的内容如下 补充org和project信息到.sentrylrc 3）、注入异常我们在代码中，注入一些异常，并指定release版本 4)、构建代码运行命令1npm run build 最终会在根目录生成dist文件夹。 5)、上传sourcemap12# sentry-cli releases files &lt;release名称&gt; upload-sourcemaps --url-prefix &lt;线上资源URI&gt; &lt;打包出来的js文件所在目录&gt;sentry-cli releases files demo-test001 upload-sourcemaps --url-prefix '~/static/js' './dist/static/js' 运行例子后的结果如图 打开sentry的项目，查看版本，会发现多了一些资源，但实际上有用的是map文件，所以在上传完成后需要根据实际情况在构建脚本中把对应的map文件删除，避免打包到生产中(其中一个原因是文件太大，另一个原因是不安全)。 6）、触发异常这时，你可以通过访问本地的http://127.0.0.1:6324，然后触发我们构建的异常，因为我本地构建了一个服务，如果你也希望构建此服务，你可以通过安装http的服务包12345# 我这个例子中线上资源是因为我在本地通过http-server起了一个服务来访问# 如果你也希望这么做，你可以npm i -g http-server cd disthttp-server -p 6324 此时会看到控制台抛出异常，同时会发送一个请求到sentry的服务器 此时打开sentry的控制台，你会看到刚才触发的错误 打开这个错误，就可以看到具体的错误信息，定位问题变得更加容易 @sentry/webpack-plugin构建上面利用sentry-cli构建时，相对麻烦，而且会暴露key等一些信息，所以我们希望利用webpack插件来加快我们的上传。 1)、安装@sentry/webpack-plugin插件, 一般会同时安装@sentry/cli1npm i @sentry/webpack-plugin --dev 2）、根目录创建.sentryclirc文件1234567[defaults]url = https://sentry.io/org = your orgproject = your project[auth]token = your token 3)、在config/prod.env.js创建环境变量12345678// config/prod.env.jsconst release = 'demo-test006'; // 可以根据package.json的版本号或者Git的tag命名process.env.RELEASE_VERSION = release;module.exports = &#123; NODE_ENV: '\"production\"', RELEASE_VERSION: `\"$&#123;release&#125;\"`,&#125; 4)、写入插件1234567891011121314// build/webpack.prod.config.jsconst SentryPlugin = require('@sentry/webpack-plugin')// ...省略一堆plugins: [ // ...省略一堆 new SentryPlugin(&#123; include: './dist', release: process.env.RELEASE_VERSION, configFile: 'sentry.properties', urlPrefix: '~/' &#125;)] 5)、运行打包1npm run build 此时在服务中打开触发错误，你就会在sentry中查看到具体的错误信息。对比cli构建的方式，webpack的优势还是蛮大的，但是利用cli的好处是我可以把token放在服务器，这样就可以避免token的泄露。 webpack-sentry-plugin构建这个包目前支持webpack1\\2\\3版本上传sourcemap，而且周下载量也达到11k。这个包有一个优势是可以在上传后删除打包后的sourcemap，可以节省后面上传打包后文件的过滤sourcemap的操作。PS: 先确保没有全局安装sentry-cli包，否则会有冲突 1)、安装webpack-sentry-plugin插件1npm install webpack-sentry-plugin --save-dev 2)、根目录创建sentry.config.js(仅仅是为了方便管理token)12345module.exports = &#123; organization: '', project: '', apiKey: '',&#125;; 3)、在config/prod.env.js创建环境变量（同上）4)、写入插件1234567891011121314151617// build/webpack.prod.config.jsconst SentryPlugin = require('webpack-sentry-plugin')// ...省略一堆plugins: [ // ...省略一堆 new SentryPlugin(Object.assign(&#123; release: process.env.RELEASE_VERSION, deleteAfterCompile: true, // exclude: /(\\.css\\.map| \\.css | \\.html)$/, include: /(\\.js\\.map | \\.js)$/, // 只上传js和map文件 filenameTransform: function (filename) &#123; return '~/' + filename &#125;, &#125;, require('../sentry.config.js')))] 5)、运行打包1npm run build 其实这个插件和官方的@sentery/webpack-plugin功能差不多，只不过多了一些配置项，例如删除sourcemap 增强sentry异常捕捉续。。 sentry的小知识点 发送邮件一般来说，sentry是默认会打开邮箱发送选项的，如果触发错误后并没有收到邮件，你可以点击下方的框框，勾选邮件 设置触发异常的用户,更有利于追踪，文档：https://docs.sentry.io/learn/context/ 12345// 一般是登录登录后获取到具体信息时带入Raven.setUserContext(&#123; user: 'xxx', id: 'sss',&#125;); Issue关联GITHUB/GITLAB（暂时用处不大）","categories":[],"tags":[{"name":"sentry","slug":"sentry","permalink":"https://jsonya.github.io/tags/sentry/"},{"name":"sourcemap","slug":"sourcemap","permalink":"https://jsonya.github.io/tags/sourcemap/"},{"name":"监控","slug":"监控","permalink":"https://jsonya.github.io/tags/监控/"},{"name":"webpack","slug":"webpack","permalink":"https://jsonya.github.io/tags/webpack/"}]},{"title":"Puppeteer爬取Gitchat课程","slug":"Puppeteer爬取Gitchat课程","date":"2018-06-26T15:37:21.000Z","updated":"2019-04-25T12:15:04.324Z","comments":true,"path":"2018/06/26/Puppeteer爬取Gitchat课程/","link":"","permalink":"https://jsonya.github.io/2018/06/26/Puppeteer爬取Gitchat课程/","excerpt":"","text":"前言最近想起GitChat的会员要过期了，但是之前购买的达人课只看了一部分，过期不能看就很可惜了，毕竟有些课程质量还是挺好的，所以就想着把课程下载下来拉到本地去看，但是Gitchat的课程并不能够把整个课程下载，需要单个单个的下载，单纯的靠人力处理就只会浪费时间，更何况我是个小coder，尽然希望通过代码来实现，机器能做就就让机器去做，所以就想起了通过爬取的方式下载下来。也许你会问为什么会想到爬虫实现，首先了解下什么是爬虫，从定义上来说，爬虫是通过脚本请求网页并分析网页来提取有效信息的一种行为，我现在的需求就是能够希望获取到所有的课程并下载，其中最重要的一点就是课程信息的获取，毫无疑问爬虫是能够实现的并且是最佳的实现方式。 技术选型 浏览器环境 因为这次爬取都是需要基于浏览器环境进行的，所以需要有浏览器环境的支持，目前达到要求的可选有puppeteer、phantomjs、selenium-webdriver；但是后两者环境配置复杂并且难用的api决定了难以担当此任； 解析文档 毋庸置疑cheerio是目前node端爬虫最好用的dom解析库，它具备了像 jquery 一样遍历跟操作DOM元素的能力，当然它只拥有解析能力，并没有事件函数； 遇到的问题也许你会问，为什么爬虫能够解决我的问题？ 登录账号问题 首先，Gitchat是没有输入框登录，它的登录方式是通过微信扫描二维码来登录，也就是和微信服务有一层绑定关系，所以第一步要解决的就是怎么绕过这层扫描登录；所以我首先想到的就是有没有通过cookie来校验登录状态，通过分析登录前后的cookie的，发现其中的一些差异极有可能是和账号有关的，所以直接把登录态的cookie获取出来来模拟登录，没想到真的成功了。。。 跳转到具体课程 通过对页面的分析得知，Gitchat里面的每个大课下的小课跳转都是通过js的onclick函数来动态控制的，所以需要分析onclick函数下的跳转规律，发现下面一行代码 然后通过正则把跳转需要的`columnId`、`id`拿到，最终也实现了跳转课程 获取下载链接 最初的想法是通过puppeteer来模拟点击的方式来跳转下载链接的，但是奇怪的是跳转后的page并不是之前创建的page，所以并不能够获取上下文环境，所以对应的api也就不能用了，所以这种方式失败了；最后分析整个文档得知下载的链接隐藏在了script里面，所以最终还是通过正则表达式匹配出来。 没有PDF下载的情况 某些课程下其实并没有提供下载功能，所以并不能够通过获取pdf链接的方式来下载，所以只能够寻求别的方法，想到既然chrome能够做的puppeteer都能做，那当然想到截屏的功能了，所以找了下puppeteer截图并打印的api，最终实现。 爬虫实现1）初始化浏览器利用puppeteer来创建浏览器环境1234567891011121314// 初始化浏览器async function openBrowser() &#123; // 创建浏览器 const browser = await puppeteer.launch(&#123; // 这个属性是控制是否有GUI界面的 headless: true, &#125;); // 创建标签页 const page = await browser.newPage(); return &#123; browser, page, &#125;&#125; 2) 跳转到首页并设置登录通过对比登陆前后的cookie，分析出customerId、customerToken是确定是否登录的参数，所以在跳转到首页后立马设置cookie值，保证下面的请求都是已登录状态1234567891011// 跳转首页async function gotoGitchat(page, browser) &#123; // 请求gitchat首页 await page.goto(GIT_CHAT_URL, &#123; timeout: 6000000 &#125;); // 设置登录的cookie await page.evaluate(() =&gt; &#123; document.cookie=\"customerId=your id\"; document.cookie=\"customerToken=your token\"; Promise.resolve(); &#125;);&#125; 3) 获取已购课程123456789101112131415161718// 获取已购课程列表async function getOrderColumns(page) &#123; // 跳转到我的已购课程 let columns = await page.goto(`$&#123;GIT_CHAT_URL&#125;/gitchat/ordered/columns`, &#123; timeout: 6000000 &#125;); // 获取dom let columnContent = await page.content(); // 加载dom const $ = cheerio.load(columnContent); // 获取已购列表 const column = $('.column'); // 返回链接和标题 return _.map(column, (item, index) =&gt; &#123; return &#123; link: item.attribs.href, title: $('.column .columnInfo .columnTitle')[index].children[0].data, &#125;; &#125;);&#125; 4) 获取下载的URL1234567891011121314151617181920212223// 获取下载urlasync function getDownLoadUrl(page, link) &#123; // 跳转到具体课程页 const column = await page.goto(`$&#123;GIT_CHAT_URL&#125;$&#123;link&#125;`, &#123; timeout: 6000000 &#125;); const topicContent = await page.$$('.columnTopics .topicTitle'); const pageContent = await page.content(); const $ = cheerio.load(pageContent); // 将课程的地址返回 return _.reduce($('.topicTitle'), (result, item, index) =&gt; &#123; const clickCallback = $('.topicTitle').eq(index).attr('onclick'); const title = $('.titleText').eq(index).text(); const idsString = clickCallback.replace(/(\\[)|(\\])|\\s+|\\'|(\\()|(\\))/g, ''); const ids = idsString.replace('clickOnTopic', '').split(','); result.push(&#123; link: !_.isEmpty(ids) ? `$&#123;GIT_CHAT_URL&#125;/gitchat/column/$&#123;ids[1]&#125;/topic/$&#123;ids[0]&#125;` : '', title, &#125;); return result; &#125;, []);&#125; 5) 下载课程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 下载对应的pdf,如果没有pdf文件下载，就打印页面async function downColumns(page, targetLink) &#123; try &#123; // 获取课程地址 const downLoadInfo = await getDownLoadUrl(page, targetLink.link); // 创建课程文件夹 console.log(`【创建$&#123;targetLink.title&#125;文件夹】`) await fs.mkdir(path.join(__dirname, '/columns', targetLink.title), function (err) &#123; if (err) throw err; &#125;); // 遍历下载所有课程 for (let i = 0; i &lt; downLoadInfo.length; i++) &#123; console.log(`【获取第$&#123;i&#125;课下载链接】`); const contentRegx = /window.location.href = '([^']+)'/; const downUrl = downLoadInfo[i].link; const downloadPath = path.join(__dirname, 'columns', targetLink.title, `$&#123;downLoadInfo[i].title&#125;.pdf`); // 跳转下载地址页 const gotoDownload = await page.goto(downUrl, &#123; timeout: 6000000 &#125;); // 获取文档内容 const downContent = await page.content(); // 如果没有下载链接的情况下，就执行截屏打印操作 if (!contentRegx.test(downContent)) &#123; console.log('【没有下载链接】：即将打印成PDF'); // 因为gitchat页面头部和底部都有导航遮挡，所以需要把他们从dom树隐藏掉 await page.$eval('body', body =&gt; &#123; body.querySelector('#header').style.display = 'none'; body.querySelector('#commentModal').nextSibling.style.display = 'none'; Promise.resolve(); &#125;); // 截屏 await page.emulateMedia('screen'); // 打印 await page.pdf(&#123; path: downloadPath &#125;); console.log(`【打印完成】: $&#123;downLoadInfo[i].title&#125;`); await sleep(1000); continue; &#125; const url = downContent.match(contentRegx)[1]; console.log(`【下载链接】:$&#123;url&#125;`); // 请求下载链接并以strem形式写入文件 const downLoadReq = request.get(url); downLoadReq.pipe(fs.createWriteStream(downloadPath)); console.log('【下载完成】'); await sleep(1000); &#125; &#125; catch (e) &#123; console.log(`【ErrorTip】: $&#123;e&#125;`); &#125;&#125;; 总结这篇文章主要是讲解一下爬虫实现思路和我实现过程遇到的问题，并没有涉及太多的puppeteer的api操作，具体的操作会在学习总结那里做记录，并且实现代码也有更好的写法，比如可以并发下载（通过打开多个窗口实现）、加入重试机制等。但是毕竟只是为了解决自己的需求，怎么简单怎么来嘛哈哈。","categories":[],"tags":[{"name":"Gitchat","slug":"Gitchat","permalink":"https://jsonya.github.io/tags/Gitchat/"},{"name":"Puppeteer","slug":"Puppeteer","permalink":"https://jsonya.github.io/tags/Puppeteer/"},{"name":"爬虫","slug":"爬虫","permalink":"https://jsonya.github.io/tags/爬虫/"}]},{"title":"Centos 使用nvm 并安装node环境","slug":"Centos-使用nvm-并安装node环境","date":"2018-03-26T19:40:20.000Z","updated":"2019-04-25T12:15:04.324Z","comments":true,"path":"2018/03/26/Centos-使用nvm-并安装node环境/","link":"","permalink":"https://jsonya.github.io/2018/03/26/Centos-使用nvm-并安装node环境/","excerpt":"","text":"安装epel源 32位 1rpm -ivh http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm 64位 1rpm -ivh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm 导入key 1rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6 查看rpm是否已经安装 1rpm --version 安装nvm 安装 1curl: curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.5/install.sh | bash 重启shell 安装node1nvm install version","categories":[],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://jsonya.github.io/tags/Centos/"},{"name":"nvm","slug":"nvm","permalink":"https://jsonya.github.io/tags/nvm/"}]},{"title":"mac 修改mysql密码","slug":"mac-修改mysql密码","date":"2017-11-13T17:05:52.000Z","updated":"2019-04-25T12:15:04.324Z","comments":true,"path":"2017/11/13/mac-修改mysql密码/","link":"","permalink":"https://jsonya.github.io/2017/11/13/mac-修改mysql密码/","excerpt":"","text":"设备1mac 安全模式打开Mysql1mysqld_safe --skip-grant-tables 新窗口下修改密码 登录 1mysql -u root 修改密码 1UPDATE mysql.user SET Password=PASSWORD('NewPassword') WHERE user='root' 刷新 1FLUSH PRIVILEGES 退出 1\\q 重启 1mysql.server restart 重新登录1mysql -u root -p","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://jsonya.github.io/tags/mysql/"}]},{"title":"rvm 管理ruby&gem","slug":"rvm-管理ruby-gem","date":"2017-10-18T23:17:15.000Z","updated":"2019-04-25T12:15:04.324Z","comments":true,"path":"2017/10/18/rvm-管理ruby-gem/","link":"","permalink":"https://jsonya.github.io/2017/10/18/rvm-管理ruby-gem/","excerpt":"","text":"1系统： macOS whatRVM 是一个命令行工具，可以提供一个便捷的多版本 Ruby 环境的管理和切换 https://rvm.io/ install前提是安装了xcode 12345curl -sSL https://get.rvm.io | bash -s stablesource ~/.bashrcsource ~/.bash_profile change ghost切换ruby-china的镜像 1echo \"ruby_url=https://cache.ruby-china.org/pub/ruby\" &gt; ~/.rvm/user/db use ruby 列出已知的 Ruby 版本 1rvm list known 安装一个 Ruby 版本 1rvm install 2.4.1 切换 Ruby 版本 1rvm use 2.4.1 查询已经安装的版本 1rvm list 移除版本 1rvm remove 2.4.1 install rails 安装rails1gem install rails","categories":[],"tags":[{"name":"rvm","slug":"rvm","permalink":"https://jsonya.github.io/tags/rvm/"},{"name":"ruby","slug":"ruby","permalink":"https://jsonya.github.io/tags/ruby/"},{"name":"gem","slug":"gem","permalink":"https://jsonya.github.io/tags/gem/"}]},{"title":"Git 多公钥管理","slug":"Git-多公钥管理","date":"2017-10-12T20:09:19.000Z","updated":"2019-04-25T12:15:04.324Z","comments":true,"path":"2017/10/12/Git-多公钥管理/","link":"","permalink":"https://jsonya.github.io/2017/10/12/Git-多公钥管理/","excerpt":"","text":"生成ssh key1ssh-keygen -t rsa -C \"my@mail.com\" 第一个问询命令是创建的公钥名，这里不要直接enter，键入能理解的公钥名如id_rsa_github，二三个命令是询问密码，无需输入 当然，也可以直接强制输入直接生成1ssh-keygen -t rsa -C \"my@mail.com\" -f ~/.ssh/id-rsa_github 将公钥添加到仓库的ssh key管理生成key管理创建config文件，123456# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github User Jsonya 添加公钥1ssh-add ~/.ssh/id_rsa_gitlab 测试是否添加成功1ssh -T git@gitlab.com 重置全局name12git config --global --unset user.namegit config --global --unset user.email 如果之前创建过全局的name则运行上面的命令，重置，然后在项目的仓库中设置局部的name和email","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://jsonya.github.io/tags/Git/"},{"name":"ssh","slug":"ssh","permalink":"https://jsonya.github.io/tags/ssh/"}]},{"title":"纯记录nvm管理node版本","slug":"nvm-manage","date":"2017-10-11T17:36:53.000Z","updated":"2019-04-25T12:15:04.324Z","comments":true,"path":"2017/10/11/nvm-manage/","link":"","permalink":"https://jsonya.github.io/2017/10/11/nvm-manage/","excerpt":"","text":"1系统： macOS 安装原本打算用homebrew安装，但是看了下nvm的说明目前homebrew还不支持，故放弃 系统是macOS,所以需要先安装xcode，不想安装的话就xcode-select --install安装需要的 curl1curl: curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.5/install.sh | bash wget1wget: wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.5/install.sh | bash 安装完后还需要在~/.zshrc添加12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 安装nodejs 安装指定版本的 Node.js 1nvm install [version] 指定当前使用的 Node.js 版本 1nvm use [version] 查看当前安装的 Node.js 版本列表 1nvm ls 查看远程可安装的版本 12nvm ls-remotenvm ls-remote --lts //稳定版本 切换最新版本 1nvm use node 设定默认版本 1nvm alias default [version] 当前使用版本 1nvm current 项目下正常来说项目目录下会有一个.nvm记录了项目所使用的node版本的，所以直接运行nvm use就可以切换node版本为项目所使用的版本","categories":[],"tags":[{"name":"nvm","slug":"nvm","permalink":"https://jsonya.github.io/tags/nvm/"},{"name":"node","slug":"node","permalink":"https://jsonya.github.io/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://jsonya.github.io/tags/npm/"}]}]}